{"version":1,"ops":[{"type":3,"author":{"id":"e1ed4ba4057c568be8b7eab5486fd5c04def1601"},"timestamp":1579235126,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU3NTQ1ODcwMg==","github-url":"https://github.com/fraction/oasis/issues/58#issuecomment-575458702"},"message":"Also, the name field is `null`. Idk if that's purposeful, but I personally like the use of the first `n` characters of the public key as the defacto name.","files":null},{"type":3,"author":{"id":"6a0aeab8ae8e7bf93407c51e9b2a4d9d0273c9ad"},"timestamp":1579281285,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU3NTcwOTg3Mw==","github-url":"https://github.com/fraction/oasis/issues/58#issuecomment-575709873"},"message":"Good idea! I'd love to merge this improvement. The only Big Decision to make is whether we want to use Sharp (which is an optional dependency because it's hard to build) or whether we want it to work for everyone. For example, if we took the first six bytes of someone's public key we could generate a 1x1 GIF with that hex color (which the browser would stretch for us). I sketched out a super quick example:\n\n```javascript\n// This is a tiny white GIF encoded with base64.\nconst magicBytes = \"R0lGODlhAQABAIABAP///wAAACwAAAAAAQABAAACAkQBADs=\"\nconst whiteGif = Buffer.from(magicBytes, \"base64\")\n\n// We need to insert our color at offset 13 to replace bytes 13, 14, and 15.\nconst colorOffset = 13\nconst colorLength = 3\n\n// The start and end of the GIF never change, so we can repeatedly copy them.\nconst gifStart = whiteGif.slice(0, colorOffset)\nconst gifEnd = whiteGif.slice(colorOffset + colorLength)\n\nconst hexGif = input =\u003e {\n  // Only convert last 6 characters, so `ffffff` and `#ffffff` are equivalent.\n  const hexColor = input.slice(-6)\n  const gifCopy = Buffer.from(whiteGif)\n  const colorBytes = Buffer.from(hexColor, \"hex\")\n  return Buffer.concat([gifStart, colorBytes, gifEnd])\n}\n\n// This is just an example, we wouldn't need to write to the filesystem in Oasis.\nconst output = hexGif(\"#ff00ff\")\nrequire(\"fs\").writeFileSync(\"out.gif\", output)\n```\n\n![out](https://user-images.githubusercontent.com/537700/72630584-7e9d1700-3907-11ea-9eb3-c0bd67fc32a4.gif)\n\n^ It's hard to see, but I've uploaded the corresponding GIF above. ([Link](https://user-images.githubusercontent.com/537700/72630584-7e9d1700-3907-11ea-9eb3-c0bd67fc32a4.gif))\n\n\u003e Also, the name field is null. Idk if that's purposeful, but I personally like the use of the first n characters of the public key as the defacto name.\n\nWorks for me!","files":null},{"type":6,"author":{"id":"6a0aeab8ae8e7bf93407c51e9b2a4d9d0273c9ad"},"timestamp":1579281285,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDMzOTY5NDI5Nw=="},"target":"41a4858af6d0f42b23c8df28045ca8c65350f4620ade69e84b42fce47d6e19ca","message":"Good idea! I'd love to merge this improvement. The only Big Decision to make is whether we want to use Sharp (which is an optional dependency because it's hard to build) or whether we want it to work for everyone. For example, if we took the first six bytes of someone's public key we could generate a 1x1 GIF with that hex color (which the browser would stretch for us). I sketched out a super quick example:\n\n```javascript\n// This is a tiny white GIF encoded with base64.\nconst magicBytes = \"R0lGODlhAQABAIABAP///wAAACwAAAAAAQABAAACAkQBADs=\"\nconst whiteGif = Buffer.from(magicBytes, \"base64\")\n\n// We need to insert our color at offset 13 to replace bytes 13, 14, and 15.\nconst colorOffset = 13\nconst colorLength = 3\n\n// The start and end of the GIF never change, so we can repeatedly copy them.\nconst gifStart = whiteGif.slice(0, colorOffset)\nconst gifEnd = whiteGif.slice(colorOffset + colorLength)\n\nconst hexGif = input =\u003e {\n  // Only convert last 6 characters, so `ffffff` and `#ffffff` are equivalent.\n  const hexColor = input.slice(-6)\n  const colorBytes = Buffer.from(hexColor, \"hex\")\n  return Buffer.concat([gifStart, colorBytes, gifEnd])\n}\n\n// This is just an example, we wouldn't need to write to the filesystem in Oasis.\nconst output = hexGif(\"#ff00ff\")\nrequire(\"fs\").writeFileSync(\"out.gif\", output)\n```\n\n![out](https://user-images.githubusercontent.com/537700/72630584-7e9d1700-3907-11ea-9eb3-c0bd67fc32a4.gif)\n\n^ It's hard to see, but I've uploaded the corresponding GIF above. ([Link](https://user-images.githubusercontent.com/537700/72630584-7e9d1700-3907-11ea-9eb3-c0bd67fc32a4.gif))\n\n\u003e Also, the name field is null. Idk if that's purposeful, but I personally like the use of the first n characters of the public key as the defacto name.\n\nWorks for me!","files":null},{"type":6,"author":{"id":"6a0aeab8ae8e7bf93407c51e9b2a4d9d0273c9ad"},"timestamp":1579292796,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDMzOTc5MDUwMg=="},"target":"41a4858af6d0f42b23c8df28045ca8c65350f4620ade69e84b42fce47d6e19ca","message":"Good idea! I'd love to merge this improvement. The only Big Decision to make is whether we want to use Sharp (which is an optional dependency because it's hard to build) or whether we want it to work for everyone. For example, if we took the first six bytes of someone's public key we could generate a 1x1 GIF with that hex color (which the browser would stretch for us). I sketched out a super quick example: https://github.com/christianbundy/hex-gif\n\n```javascript\nconst hexGif = require(\"hex-gif\")\n\n// We don't really need to write to the filesystem in Oasis.\nconst output = hexGif(\"#ff00ff\")\nrequire(\"fs\").writeFileSync(\"out.gif\", output)\n```\n\n![out](https://user-images.githubusercontent.com/537700/72630584-7e9d1700-3907-11ea-9eb3-c0bd67fc32a4.gif)\n\n^ It's hard to see, but I've uploaded the corresponding GIF above. ([Link](https://user-images.githubusercontent.com/537700/72630584-7e9d1700-3907-11ea-9eb3-c0bd67fc32a4.gif))\n\n\u003e Also, the name field is null. Idk if that's purposeful, but I personally like the use of the first n characters of the public key as the defacto name.\n\nWorks for me!","files":null},{"type":3,"author":{"id":"6a0aeab8ae8e7bf93407c51e9b2a4d9d0273c9ad"},"timestamp":1579281932,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU3NTcxNTI5NQ==","github-url":"https://github.com/fraction/oasis/issues/58#issuecomment-575715295"},"message":"\u003e Sharp (which is an optional dependency because it's hard to build)\n\nContext: Sharp is only used to resize images, like profile images, before they're transferred to the browser. Lots of profile images are *huge*, so if we can resize them then we can avoid taking an 8 megapixel photo and resizing it to 40x40 pixels or whatever, but we can just fallback to the browser resizing if the `npm install` fails.","files":null},{"type":6,"author":{"id":"6a0aeab8ae8e7bf93407c51e9b2a4d9d0273c9ad"},"timestamp":1579281932,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDMzOTcwMDEwNA=="},"target":"0539819662943c905fc51ef0563cc5a3584e49bcdf82491a15c63e57c4bdcdb9","message":"\u003e Sharp (which is an optional dependency because it's hard to build)\n\nContext: Sharp is only used to resize images, like profile images, before they're transferred to the browser. Lots of profile images are *huge*, so if we can resize them then we can avoid taking an 8 megapixel photo and resizing it to 40x40 pixels or whatever and holding that memory in the browser tab, but we can just fallback to the browser resizing if the `npm install` fails.","files":null},{"type":5,"author":{"id":"6a0aeab8ae8e7bf93407c51e9b2a4d9d0273c9ad"},"timestamp":1579452157,"metadata":{"github-id":"MDEyOkxhYmVsZWRFdmVudDI5NjEwMDU2NjQ="},"added":["topic:enhancement"],"removed":[]}]}